<!DOCTYPE HTML>
<!--
	Hyperspace by HTML5 UP
	html5up.net | @ajlkn
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html>
	<head>
		<title>Making Refraction</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
		<link rel="stylesheet" href="assets/css/main.css" />
		<noscript><link rel="stylesheet" href="assets/css/noscript.css" /></noscript>
	</head>
	<body class="is-preload">

		<!-- Header -->
			<header id="header">
				<a href="index.html" class="title">Hyperspace</a>
				<nav>
					<ul>
						<li><a href="index.html">Home</a></li>
						<li><a href="refraction_page.html" class="active">Refraction</a></li>
						<li><a href="elements.html">Elements</a></li>
					</ul>
				</nav>
			</header>

		<!-- Wrapper -->
			<div id="wrapper">

				<!-- Main -->
					<section id="main" class="wrapper">
						<div class="inner">
							<h1 class="major">Making Refraction</h1>
							<span class="image fit"><img src="images/LightingShowcase.gif" alt="" /></span>
							<p>
								Refraction is one of my favorite and one of the most challenging projects I've worked on yet. A fast cpu based lighting engine and renderer. Due to it being cpu based I had to do a lot of low 
								level optimization. While looking at the memory used I realised that it was very cashe incoherant, in order to fix this
								I made my own custom datatype for colors. This allowed them to be as small as possible so they could fit in the cashe. Another optimization I did was multi-threading the lighting calculations.
								With threads able to take a set of pixels and solve them in parallel, the program ran much more efficiently.<br />

								<h3>How it works:</h3>
								<ol>
									<li>All objects and tilesets are merged together into one image (the normal maps are also merged into a seperate image).</li>
									<li>For each light we then go over each pixel in its range and calcuate the lights strength, using the normal map to factor in the surface normal.</li>
									<li>The individual lights strength are added together resulting in the total brightness.</li>
									<li>We then apply any post prossessing effects, like dithering and scanlines.</li>
								</ol>

								<h3>Code Sample</h3>
								<pre><code>#DEFINE DEGREES_TO_RADIANS 0.01745329251994329577f //Precomputed degrees to radians conversion ratio

									
float Renderer::FindPixelLuminosity(float x, float y, Light* LightSource)
{
	float normalMin = 0.75f;
	Vector2 lightP = LightSource->position - CameraP;
	float result = 0.0f;

	//Determine which algorithm to use based on lightsource type
	switch (LightSource->Type)
	{
		case LightSourceType_Point:
		{
			Vector2 dist = Vector2(x, y) - lightP;
			float distFromConeCenter = sqrt(Vector2::DotProduct(dist, dist)) / LightSource->radius;

			if (distFromConeCenter >= 1.0)
				return 0.0;

			float distFromConeCenterSquared = distFromConeCenter * distFromConeCenter;
			result = LightSource->intensity * pow((1 - distFromConeCenterSquared), 2) / (1 + LightSource->radialFalloff * distFromConeCenter);
		} break;

		case LightSourceType_Directional:
		{
			float AngleRadians = DEGREES_TO_RADIANS * -LightSource->angle;
			float MinAngleRadians = DEGREES_TO_RADIANS * -LightSource->minAngle;
			float MaxAngleRadians = DEGREES_TO_RADIANS * -LightSource->maxAngle;

			Vector2 FrustumLeftEdge = Vector2(-sinf(MinAngleRadians), cosf(MinAngleRadians));
			Vector2 FrustumRightEdge = Vector2(-sinf(MaxAngleRadians), cosf(MaxAngleRadians));
			float dRadius = Vector2::Length(FrustumRightEdge - FrustumLeftEdge);

			Vector2 EmissionDirection = Vector2(-sinf(AngleRadians), cosf(AngleRadians));
			Vector2 EmissionTangent = Vector2(-EmissionDirection.y, EmissionDirection.x);
			Vector2 ToPixel = Vector2(x, y) - lightP;

			float Dot = Vector2::DotProduct(ToPixel, EmissionDirection);
			if (Dot > 0.0f)
			{
				float DistanceSq = Vector2::DotProduct(ToPixel, ToPixel);
				float Radius = Dot * dRadius;
				float distance = sqrt(DistanceSq);
				float s = distance / LightSource->radius;

				if (s >= 1.0)
					return 0.0;

				float s2 = s * s;
				float EmitterDistance = LightSource->intensity * pow((1 - s2), 2) / (1 + LightSource->radialFalloff * s);
				float FrustumDistance = (Radius - (fabsf(Vector2::DotProduct(EmissionTangent, ToPixel))));
		
				if (FrustumDistance < 0.0f)
				{
					FrustumDistance = 0.0f;
				}
				if (FrustumDistance > Radius)
				{
					FrustumDistance = Radius;
				}
				result = EmitterDistance * (FrustumDistance * LightSource->frustumWeight);
			}
		} break;

		default:
		{
			assert(!"Encountered a light source of an unknown type.");
		} break;
	}

	//Normal map calculations
	if (result > 0 && doFog != true)
	{
		if (x + CameraP.x <= normalBuffer->BufferSizeX && x + CameraP.x >= 0 && y + CameraP.y <= normalBuffer->BufferSizeY && y + CameraP.y >= 0)
		{
			float normalR = normalBuffer->SampleColor(x + CameraP.x, y + CameraP.y).r;
			float normalG = normalBuffer->SampleColor(x + CameraP.x, y + CameraP.y).g;

			if (normalR == 0 && normalG == 0)
			{
				return result;
			}

			Vector2 pos = (Vector2(x, y));
			Vector2 distFromLight = lightP - pos;
			Vector2 distNormalized;
			Vector2 normalDir = Vector2{ normalR / 255.0f, normalG / 255.0f };
			normalDir *= 2;
			normalDir -= Vector2{ 1,1 };
			distNormalized.Normalize(distNormalized, distFromLight);
			float normalFalloff = -Vector2::DotProduct(distNormalized, normalDir);
			normalFalloff += normalMin;
			normalFalloff = clamp(normalFalloff, 0.0f, 1.0f);
			result = (normalFalloff * normalStrength * result);
		}
	}

	return result;
}

void Renderer::RenderLightingPass()
{
#if 1
	const int xSize = (int)outputBuffer->size.x;
	const int ySize = (int)outputBuffer->size.y;

	float lightMultiplier = 0.0f;

	float IntensityR = 0.0f;
	float IntensityG = 0.0f;
	float IntensityB = 0.0f;
#pragma omp parallel
	{
#pragma omp for collapse(3) nowait private(lightMultiplier, IntensityR, IntensityG, IntensityB)
		for (int x = 0; x < xSize; ++x)
		{
			for (int y = 0; y < ySize; ++y)
			{
				IntensityR = 0.0f;
				IntensityG = 0.0f;
				IntensityB = 0.0f;

				for (int i = 0; i < numLights; ++i)
				{
					if (CalculateIfPixelIsLit(x, y, i) == true || doFog == true)
					{
						Light* LightSource = lightSource + i;
						lightMultiplier = FindPixelLuminosity(x, y, LightSource);

						if (lightMultiplier != 0)
						{
							float R_F32 = (LightSource->color.GetRed()) * OneOver255;
							float G_F32 = (LightSource->color.GetGreen()) * OneOver255;
							float B_F32 = (LightSource->color.GetBlue()) * OneOver255;
							lightMultiplier *= LightSource->volumetricIntensity;

							IntensityR += (lightMultiplier * R_F32);
							IntensityG += (lightMultiplier * G_F32);
							IntensityB += (lightMultiplier * B_F32);
						}
					}
				}

				lightR[x][y] = IntensityR;
				lightG[x][y] = IntensityG;
				lightB[x][y] = IntensityB;
			}
		}
	}
#else
	inputBuffer->Blit(outputBuffer);
#endif
}
</code></pre>
							</p>
							<p></p>
						</div>
					</section>

			</div>

		<!-- Footer -->
			<footer id="footer" class="wrapper alt">
				<div class="inner">
					<ul class="menu">
						<li>&copy; Tyler Dean. All rights reserved.</li><li>Base Design: <a href="http://html5up.net">HTML5 UP</a></li>
					</ul>
				</div>
			</footer>

		<!-- Scripts -->
			<script src="assets/js/jquery.min.js"></script>
			<script src="assets/js/jquery.scrollex.min.js"></script>
			<script src="assets/js/jquery.scrolly.min.js"></script>
			<script src="assets/js/browser.min.js"></script>
			<script src="assets/js/breakpoints.min.js"></script>
			<script src="assets/js/util.js"></script>
			<script src="assets/js/main.js"></script>

	</body>
</html>