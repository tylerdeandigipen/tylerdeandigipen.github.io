<!DOCTYPE HTML>
<!--
	Hyperspace by HTML5 UP
	html5up.net | @ajlkn
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html>
	<head>
		<title>Making Refraction</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
		<link rel="stylesheet" href="assets/css/main.css" />
		<noscript><link rel="stylesheet" href="assets/css/noscript.css" /></noscript>
	</head>
	<body class="is-preload">

		<!-- Header -->
			<header id="header">
				<a href="index.html" class="title">Hyperspace</a>
				<nav>
					<ul>
						<li><a href="index.html">Home</a></li>
						<li><a href="refraction_page.html" class="active">Refraction</a></li>
						<li><a href="elements.html">Elements</a></li>
					</ul>
				</nav>
			</header>

		<!-- Wrapper -->
			<div id="wrapper">

				<!-- Main -->
					<section id="main" class="wrapper">
						<div class="inner">
							<h1 class="major">Making Refraction</h1>
							<span class="image fit"><img src="images/LightingShowcase.gif" alt="" /></span>
							<p>
								Refraction is one of my favorite and one of the most challenging projects I've worked on yet. A fast cpu based lighting engine and renderer. Due to it being cpu based I had to do a lot of low 
								level optimization. While looking at the memory used I realised that it was very cashe incoherant, in order to fix this
								I made my own custom datatype for colors. This allowed them to be as small as possible so they could fit in the cashe. Another optimization I did was multi-threading the lighting calculations.
								With threads able to take a set of pixels and solve them in parallel, the program ran much more efficiently.<br />

								<h3>How it works:</h3>
								<ol>
									<li>All objects and tilesets are merged together into one image (the normal maps are also merged into a seperate image).</li>
									<li>For each light we then go over each pixel in its range and calcuate the lights strength, using the normal map to factor in the surface normal.</li>
									<li>The individual lights strength are added together resulting in the total brightness.</li>
									<li>We then apply any post prossessing effects, like dithering and scanlines.</li>
								</ol>

								<h3>Code Sample</h3>
								<pre><code>#DEFINE DEGREES_TO_RADIANS 0.01745329f //Precomputed degrees to radians conversion ratio

//calculate the given lightsource's effect on the current pixel
float Renderer::FindPixelLuminosity(float x, float y, Light* lightSource)
{
	float normalMin = 0.75f;
	Vector2 lightP = lightSource->position - CameraP;
	float result = 0.0f;

	//Determine which algorithm to use based on lightsource type
	switch (lightSource->Type)
	{
		case LightSourceType_Point:
		{
			Vector2 dist = Vector2(x, y) - lightP;
			float distFromConeCenter = sqrt(Vector2::DotProduct(dist, dist)) / lightSource->radius;

			//if the current pixel is outside the lights radius
			if (distFromConeCenter >= 1.0)
				return 0.0;

			float distFromConeCenterSquared = distFromConeCenter * distFromConeCenter;
			result = lightSource->intensity * pow((1 - distFromConeCenterSquared), 2) / (1 + lightSource->radialFalloff * distFromConeCenter);
		} break;

		case LightSourceType_Directional:
		{
			float AngleRadians = DEGREES_TO_RADIANS * -lightSource->angle;
			float MinAngleRadians = DEGREES_TO_RADIANS * -lightSource->minAngle;
			float MaxAngleRadians = DEGREES_TO_RADIANS * -lightSource->maxAngle;

			//find edges of the viewcone
			Vector2 FrustumLeftEdge = Vector2(-sinf(MinAngleRadians), cosf(MinAngleRadians));
			Vector2 FrustumRightEdge = Vector2(-sinf(MaxAngleRadians), cosf(MaxAngleRadians));
			float dRadius = Vector2::Length(FrustumRightEdge - FrustumLeftEdge);

			Vector2 EmissionDirection = Vector2(-sinf(AngleRadians), cosf(AngleRadians));
			Vector2 EmissionTangent = Vector2(-EmissionDirection.y, EmissionDirection.x);
			Vector2 ToPixel = Vector2(x, y) - lightP;

			float Dot = Vector2::DotProduct(ToPixel, EmissionDirection);
			//check if current pixel is inside the lights viewcone
			if (Dot > 0.0f)
			{
				float DistanceSq = Vector2::DotProduct(ToPixel, ToPixel);
				float Radius = Dot * dRadius;
				float distance = sqrt(DistanceSq);
				float s = distance / lightSource->radius;

				//leave early if the current pixel is outside the light sources radius
				if (s >= 1.0)
					return 0.0;

				float s2 = s * s;
				float emitterDistance = lightSource->intensity * pow((1 - s2), 2) / (1 + lightSource->radialFalloff * s);
				float frustumDistance = (Radius - (fabsf(Vector2::DotProduct(emissionTangent, ToPixel))));
		
				if (frustumDistance < 0.0f)
				{
					frustumDistance = 0.0f;
				}
				if (frustumDistance > Radius)
				{
					frustumDistance = Radius;
				}
				result = emitterDistance * (frustumDistance * lightSource->frustumWeight);
			}
		} break;

		default:
		{
			assert(!"Encountered a light source of an unknown type.");
		} break;
	}

	//Do normal map calculations if light isnt pure dark
	if (result > 0)
	{
		if (x + CameraP.x <= normalBuffer->BufferSizeX && x + CameraP.x >= 0 && y + CameraP.y <= normalBuffer->BufferSizeY && y + CameraP.y >= 0)
		{
			float normalR = normalBuffer->SampleColor(x + CameraP.x, y + CameraP.y).r;
			float normalG = normalBuffer->SampleColor(x + CameraP.x, y + CameraP.y).g;

			if (normalR == 0 && normalG == 0)
			{
				return result;
			}

			Vector2 pos = (Vector2(x, y));
			Vector2 distFromLight = lightP - pos;
			Vector2 distNormalized;
			Vector2 normalDir = Vector2{ normalR / 255.0f, normalG / 255.0f };
			normalDir *= 2;
			normalDir -= Vector2{ 1,1 };
			distNormalized.Normalize(distNormalized, distFromLight);
			float normalFalloff = -Vector2::DotProduct(distNormalized, normalDir);
			normalFalloff += normalMin;
			normalFalloff = clamp(normalFalloff, 0.0f, 1.0f);
			result = (normalFalloff * normalStrength * result);
		}
	}

	return result;
}

//Loop over every pixel and calculate each pixels rgb value
void Renderer::RenderLightingPass()
{
	const int xSize = outputBuffer->size.x;
	const int ySize = outputBuffer->size.y;

	float lightMultiplier = 0.0f;

	float intensityR = 0.0f;
	float intensityG = 0.0f;
	float intensityB = 0.0f;

//create a threadpool
#pragma omp parallel
	{
//create tasks for threads, make each take one index of the next three loops, dont have them wait for other threads to finish, give private variables
#pragma omp for collapse(3) nowait private(lightMultiplier, intensityR, intensityG, intensityB)
		for (int x = 0; x < xSize; ++x)
		{
			for (int y = 0; y < ySize; ++y)
			{
				intensityR = 0.0f;
				intensityG = 0.0f;
				intensityB = 0.0f;

				for (int i = 0; i < numLights; ++i)
				{
					if (CalculateIfPixelIsLit(x, y, i) == true || doFog == true)
					{
						Light* lightSource = lightSource + i;
						lightMultiplier = FindPixelLuminosity(x, y, lightSource);

						if (lightMultiplier != 0)
						{
							//convert from 0 - 255 to 0 - 1
							float R_F32 = (lightSource->color.GetRed()) * OneOver255;
							float G_F32 = (lightSource->color.GetGreen()) * OneOver255;
							float B_F32 = (lightSource->color.GetBlue()) * OneOver255;
						
							lightMultiplier *= LightSource->volumetricIntensity;

							//multiply by volumetric intesity to simulate fog (lets you see the light beam itself)
							intensityR += (lightMultiplier * R_F32);
							intensityG += (lightMultiplier * G_F32);
							intensityB += (lightMultiplier * B_F32);
						}
					}
				}

				lightR[x][y] = intensityR;
				lightG[x][y] = intensityG;
				lightB[x][y] = intensityB;
			}
		}
	}
}
</code></pre>
							</p>
							<p></p>
						</div>
					</section>

			</div>

		<!-- Footer -->
			<footer id="footer" class="wrapper alt">
				<div class="inner">
					<ul class="menu">
						<li>&copy; Tyler Dean. All rights reserved.</li><li>Base Design: <a href="http://html5up.net">HTML5 UP</a></li>
					</ul>
				</div>
			</footer>

		<!-- Scripts -->
			<script src="assets/js/jquery.min.js"></script>
			<script src="assets/js/jquery.scrollex.min.js"></script>
			<script src="assets/js/jquery.scrolly.min.js"></script>
			<script src="assets/js/browser.min.js"></script>
			<script src="assets/js/breakpoints.min.js"></script>
			<script src="assets/js/util.js"></script>
			<script src="assets/js/main.js"></script>

	</body>
</html>