<!DOCTYPE HTML>
<!--
	Hyperspace by HTML5 UP
	html5up.net | @ajlkn
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html>
	<head>
		<title>Making Refraction</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
		<link rel="stylesheet" href="assets/css/main.css" />
		<noscript><link rel="stylesheet" href="assets/css/noscript.css" /></noscript>
	</head>
	<body class="is-preload">

		<!-- Header -->
			<header id="header">
				<a href="index.html" class="title">Hyperspace</a>
				<nav>
					<ul>
						<li><a href="index.html">Home</a></li>
						<li><a href="refraction_page.html" class="active">Refraction</a></li>
						<li><a href="elements.html">Elements</a></li>
					</ul>
				</nav>
			</header>

		<!-- Wrapper -->
			<div id="wrapper">

				<!-- Main -->
					<section id="main" class="wrapper">
						<div class="inner">
							<h1 class="major">Making Refraction</h1>
							<span class="image fit"><img src="images/LightingShowcase.gif" alt="" /></span>
							<p>
								Refraction is one of my favorite and one of the most challenging projects I've worked on yet. A fast cpu based lighting engine and renderer. Due to it being cpu based I had to do a lot of low 
								level optimization. While looking at the memory used I realised that it was very cashe incoherant, in order to fix this
								I made my own custom datatype for colors. This allowed them to be as small as possible so they could fit in the cashe. Another optimization I did was multi-threading the lighting calculations.
								With threads able to take a set of pixels and solve them in parallel, the program ran much more efficiently.<br />

								<h3>How it works:</h3>
								<ol>
									<li>All objects and tilesets are merged together into one image (the normal maps are also merged into a seperate image).</li>
									<li>For each light we then go over each pixel in its range and calcuate the lights strength, using the normal map to factor in the surface normal.</li>
									<li>The individual lights strength are added together resulting in the total brightness.</li>
									<li>We then apply any post prossessing effects, like dithering and scanlines.</li>
								</ol>

								<h3>Code Sample</h3>
								<pre><code>float Renderer::FindPixelLuminosity(float x, float y, Light* LightSource)
{
	float normalMin = 0.75f;
	Vector2 LightP = LightSource->position - CameraP;
	float Result = 0.0f;

	switch (LightSource->Type)
	{
		case LightSourceType_Point:
		{
			Vector2 D = Vector2(x, y) - LightP;
			float DistanceSq = Vector2::DotProduct(D, D);
			float distance = sqrt(DistanceSq);
			float s = distance / LightSource->radius;
			if (s >= 1.0)
			return 0.0;
			float s2 = s * s;
			Result = LightSource->intensity * (float)pow((1 - s2), 2) / (1 + LightSource->radialFalloff * s);
		} break;

		case LightSourceType_Directional:
		{
			float DegreesToRadians = 0.01745329251994329577f;
			float AngleRadians = DegreesToRadians * -LightSource->angle;
			float MinAngleRadians = DegreesToRadians * -LightSource->minAngle;
			float MaxAngleRadians = DegreesToRadians * -LightSource->maxAngle;

			Vector2 FrustumLeftEdge = Vector2(-sinf(MinAngleRadians), cosf(MinAngleRadians));
			Vector2 FrustumRightEdge = Vector2(-sinf(MaxAngleRadians), cosf(MaxAngleRadians));
			float dRadius = Vector2::Length(FrustumRightEdge - FrustumLeftEdge);

			Vector2 EmissionDirection = Vector2(-sinf(AngleRadians), cosf(AngleRadians));
			Vector2 EmissionTangent = Vector2(-EmissionDirection.y, EmissionDirection.x);
			Vector2 ToPixel = Vector2(x, y) - LightP;

			float Dot = Vector2::DotProduct(ToPixel, EmissionDirection);
			if (Dot > 0.0f)
			{
				float DistanceSq = Vector2::DotProduct(ToPixel, ToPixel);
				float Radius = Dot * dRadius;
				float distance = sqrt(DistanceSq);
				float s = distance / LightSource->radius;

				if (s >= 1.0)
					return 0.0;

				float s2 = s * s;
				float EmitterDistance = LightSource->intensity * (float)pow((1 - s2), 2) / (1 + LightSource->radialFalloff * s);
				float FrustumDistance = (Radius - (fabsf(Vector2::DotProduct(EmissionTangent, ToPixel))));
		
				if (FrustumDistance < 0.0f)
				{
					FrustumDistance = 0.0f;
				}
				if (FrustumDistance > Radius)
				{
					FrustumDistance = Radius;
				}
				Result = EmitterDistance * (FrustumDistance * LightSource->frustumWeight);
			}
		} break;

		default:
		{
			assert(!"Encountered a light source of an unknown type.");
		} break;
	}

	//Normal map calculations
	if (Result > 0 && doFog != true)
	{
		if (x + CameraP.x <= normalBuffer->BufferSizeX && x + CameraP.x >= 0 && y + CameraP.y <= normalBuffer->BufferSizeY && y + CameraP.y >= 0)
		{
			float normalR = (float)normalBuffer->SampleColor(x + CameraP.x, y + CameraP.y).r;
			float normalG = (float)normalBuffer->SampleColor(x + CameraP.x, y + CameraP.y).g;

			if (normalR == 0 && normalG == 0)
			{
				return Result;
			}

			Vector2 pos = (Vector2(x, y));
			Vector2 distFromLight = LightP - pos;
			Vector2 distNormalized;
			Vector2 normalDir = Vector2{ normalR / 255.0f, normalG / 255.0f };
			normalDir *= 2;
			normalDir -= Vector2{ 1,1 };
			distNormalized.Normalize(distNormalized, distFromLight);
			float normalFalloff = -Vector2::DotProduct(distNormalized, normalDir);
			normalFalloff += normalMin;
			normalFalloff = clamp(normalFalloff, 0.0f, 1.0f);
			Result = (normalFalloff * normalStrength * Result);
		}
	}

	return Result;
}
</code></pre>
							</p>
							<p></p>
						</div>
					</section>

			</div>

		<!-- Footer -->
			<footer id="footer" class="wrapper alt">
				<div class="inner">
					<ul class="menu">
						<li>&copy; Tyler Dean. All rights reserved.</li><li>Base Design: <a href="http://html5up.net">HTML5 UP</a></li>
					</ul>
				</div>
			</footer>

		<!-- Scripts -->
			<script src="assets/js/jquery.min.js"></script>
			<script src="assets/js/jquery.scrollex.min.js"></script>
			<script src="assets/js/jquery.scrolly.min.js"></script>
			<script src="assets/js/browser.min.js"></script>
			<script src="assets/js/breakpoints.min.js"></script>
			<script src="assets/js/util.js"></script>
			<script src="assets/js/main.js"></script>

	</body>
</html>